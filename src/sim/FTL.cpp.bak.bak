
#include "FTL.h"

FTL::FTL(Hair& h) : ISimulation(h)
{}

FTL::~FTL()
{}

void FTL::addForce(vec3 f)
{
    for(size_t s=0; s < this->hair.size(); s++)
    {
      for(size_t v=0; v < this->hair[v].size(); v++)
      {
         this->hair[s][v].Force += f;
      }
    }
}

void FTL::update()
{
  constexpr float TimeStep = 1.0f/20.0f; // mentioned as dt
  constexpr float Damping = 0.9f; //sDamping
  
  // the correction vector d_i+1 as found in euqation (9)
  vec3 d;
    for(size_t s=0; s < this->hair.size(); s++)
    {
        Strand& strand = this->hair[s];
      for(size_t v=1 /*skip the very first vertex*/; v < strand.size(); v++)
      {
	Vertex& x = strand[v];
        
        x.OldPosition = x.Position;
	
	// calc new position
	/*vec3 p = */x.Position += TimeStep * x.Velocity + TimeStep*TimeStep * x.Force; // (1)
	
	
	// solve constraints - (2)
            Vertex& pre = strand[v-1];
            
            vec3 direction = x.Position - pre.Position;
            direction = glm::normalize(direction);
            
            // backup x's unconstrained position before we're going to constraint it
            vec3 pBackup = x.Position;
            
            // constraint the new position of vertex x on a sphere of radius l0 around previous vertex
            x.Position = pre.Position + direction * pre.L0;
	// end solve constraint
      
        
        // correction vector for satisfying the constraint
        x.Correction = x.Position - pBackup; // (6)
      }
      
      for(size_t v=1 /*skip the very first vertex*/; v < strand.size()-1; v++)
      {
        Vertex& x = strand[v];
        Vertex& succ = strand[v+1];
        
	// update velocity + final position + force
// 	x.Velocity = (p - x.Position) / TimeStep; // (3)
	x.Velocity = ((x.Position - x.OldPosition) / TimeStep) + Damping * (-succ.Correction / TimeStep); // (9)
	
	x.Force = vec3(0,0,0);
      }
    }
}